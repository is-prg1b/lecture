---title: "PRG1 (8): 多相型"date: "2017.10.27"---# 多層型## `findFirstInt`~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~`findFirstInt`: 配列 (`ss: Array[Int]`) のなかから、検索キーの数 (`key: Int`) に合致する最初のデータの位置を返す。見つからない場合は -1 を返す。## `findFirstString`~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~`findFirstString`: 配列 (`ss: Array[String]`) のなかから、検索キーの文字列 (`key: String`) に合致する最初のデータの位置を返す。見つからない場合は -1 を返す。## findFirst{String vs Int}~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~瓜ふたつ．違いはどこ？## findFirst{String vs Int}~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~1. 関数名## findFirst{String vs Int}~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~1. 関数名1. 引数の型## findFirst{String vs Int}~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~1. 関数名1. 引数の型## findFirst{String vs Int}~~~ {.scala}def findFirstInt(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirstString(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~1. 関数名1. 引数の型1. `aux`の引数の型## 関数の多重定義：findFirst~~~ {.scala}def findFirst(key: Int, seq: List[Int]): Option[Int] = {  def aux(i: Int, seq: List[Int]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~~~~ {.scala}def findFirst(key: String, seq: List[String]): Option[Int] = {  def aux(i: Int, seq: List[String]): Option[Int] = {    seq match {      case Nil => None      case x :: _ if x == key => Some(i)      case _ :: rest => aux(i + 1, rest)    }  }  aux(0, seq)}~~~多重定義 (Overloading): 名前が同じで引数の型だけが異なる関数群を用意すること，あるいは同じ演算記号について引数の型に応じて異なる意味を与えること．## 型変数 `A`- 型変数の導入: `def findFirst[A] ...`    - 新たな型変数 `A` を導入する。その変数 `A` の有効範囲は `def` の範囲。    - 型変数 `A` の意味：「ある型があって、その名前をひとまず `A` としておこう」、(簡単に)「任意の型 `A` について」- 型構成子の型変数への適用: `Array[A]`    - `Array[A]`: 任意の型 `A` に関して、型構成子 `Array` を型 `A` について特殊化したもの。    - `Array` の場合 `A` は `Array` が表す配列が要素とするデータの型なので、 `Array[A]` は、`A`型のデータを要素とする配列の型と読める。## `class Array[T]`が提供する単相関数型変数に依存しない関数群~~~ {.scala}def isEmpty: Booleandef length:  Intdef size:    Int~~~## `class Array[T]`が提供する多相関数 出現する型変数が `T` だけで、返り値の型が単純なもの~~~ {.scala}def indexOf(T): intdef forall(p: (T) ⇒ Boolean): Boolean    // ∀exists(p: (T) ⇒ Boolean): Boolean          // ∃def indexOf(elem: T): int    // Array(1, 2, 3).indexOf(3) => 2def count(p: (T) ⇒ Boolean): Int // Range(1,…, 99).toArray.count(奇数) => 50~~~## `class Array[T]`が提供する多相関数 出現する型変数が`T`だけで、返り値の型が`T`を含むもの~~~ {.scala}def head: Tdef last: Tdef init: Array[T]    // Array(Vn, v) => Array(Vn)def tail: Array[T]    // Array(v, Vn) => Array(Vn)def take(Int): Array[T]    // Array(Vk, v, …) => Array(Vk)drop(Int): Array[T]    // Array(Vk, v, …) => Array(v, …)~~~## `class Array[T]`が提供する多相関数 型変数`T`が引数にも返り値にも出現するもの~~~ {.scala}def filter((T) ⇒ Boolean): Array[T]    // Array(1, 2, 3, 4, 5).filter(奇数) => Array(1, 3, 5)    // Array(1, 2, 3, 4, 5).filter((n: Int) => n%2==1)def foldLeft[B](B) ((B, T) ⇒ B): B~~~## trait Set[T] が提供する関数~~~ {.scala}isEmpty: Booleanempty: Set[A]contains(A): Booleandiff(GenSet[A]): Set[A]union(GenSet[A]): Set[A]map[B]((A) ⇒ B): Set[B]    // Array(1, 2, 3).map((x: Int) => x.toString)subsets(): Iterator[Set[A]] // Set(1, 2, 3).subsets().foreach(println)~~~# Scala の API マニュアル## Scala の API マニュアル のさがし方`scaladoc` で検索し，`API` メニューから `Current` を選択．慎重な人は `All Versions` から適切なものを選択## Scala の API マニュアル![ドキュメントのトップページ](/lecture/image/08/scaladoc-root.png)- Scala の超基本機能は右端の `scala` をクリック- その他の機能は，このページの説明を参照．## Scala のドキュメントページの機能![ドキュメントのトップページ](/lecture/image/08/scaladoc-array.png)- パッケージ名がクリックできる- クラスと Companion オブジェクトの切り替え- `trait` を用いたドキュメントのフィルタ（慣れるとかなり便利）## ドキュメント閲覧ソフトMacユーザ: [Dash](https://kapeli.com/dash) （強力な検索能力）Windows 10 ユーザ: [Zeal](https://zealdocs.org/) （Dash に啓発された Win アプリ）ドキュメントダウンロード機能でScala のドキュメントをダウンロードして利用．### どちらも利用できない人[本家のドキュメントをダウンロード](http://scala-lang.org/download/all.html)して利用。自分が利用している Scala のバージョン(2.12.4 かな)のページを開き、API DocsのZipファイル (例えば `scala-docs-2.12.4.zip`) をダウンロードしたあとで展開して利用する。## クラスとCompanionオブジェクト （連れ合いのオブジェクト）~~~ {.scala}class Int vs object Intclass Array vs object Arrayclass List vs object Listtrait Set vs object Set~~~## class Int vs object Int### class `Int`~~~ {.scala}算術演算子: +, -, *, /比較演算子: >, <, ==ビット毎演算子min, max, signum~~~### object `Int`~~~ {.scala}Int.MaxValue (= 2147483647), Int.MinValue (= -2147483648) // class Intに関する情報Int.toString~~~## class Array vs object Array`class Array` については，すでに取り上げたので省略### object Array~~~ {.scala}empty[T]: Array[T]emptyIntArray: Array[Int]fill[T](Int)(elem: => T): Array[T]  // Array.fill(5)(3)  // Array.fill(100)(math.random)ofDim[T](n1: Int, n2: Int): Array[Array[T]]  // Array.ofDim[Int](3, 4)tabulate[T](n1: Int, n2: Int, n3: Int)(f: (Int, Int, Int) ⇒ T): Array[T]  // Array.tabulate[Double](3, 3)((n1: Int, n2: Int) => if (n1 == n2) 1.0 else 0.0)~~~## object List~~~ {.scala}empty[A]: List[A]iterate[A](A, int)((A) ⇒ A)  //List.iterate(List.empty[Int], 4)((l: List[Int]) => 0::l)range[T](T, T)  // List.range(0, 20, 3)~~~